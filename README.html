<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="iterated-schr%C3%B6dinger-bridge-approximation-to-wasserstein-gradient-flows">Iterated Schrödinger Bridge Approximation to Wasserstein Gradient Flows</h1>
<p>This repository contains code and simulations results for the paper <a href="https://arxiv.org/abs/2406.10823"><strong>Iterated Schrödinger Bridge Approximation to Wasserstein Gradient Flows</strong></a>. The code implements our Schrödinger Bridge (SB) scheme for discrete approximation of heat flow. The SB iterations can be computed for any set of initial particles using the functions <code>entropy_SB_scheme_sinkhorn</code> and <code>entropy_SB_scheme_mcmc</code> from the script <code>SB_scheme_Entropy.py</code>.</p>
<h2 id="background">Background</h2>
<p>When the set of intial particles are independently and identically distributed realizations from a Gaussian distribution, the true gradient flow is available analytically. The SB update is written as a pushforward involving barycentric projection with respect to the Schrödinbger bridge with equal marginals. For Gaussian starting measure, all subsequent SB updates are Gaussian distributed. Since the Schrodinger bridge is explicitly available for Gaussian marginals <a href="https://proceedings.neurips.cc/paper/2020/hash/766e428d1e232bbdd58664b41346196c-Abstract.html">(Janati et al. (2020))</a>, we can explicitly compute the SB step.</p>
<p>We compare the SB update to the true gradient flow. We also push a finite number of particles using the barycentric projections and illustrate how they provide a discretized sample approximation of the true gradient flow. To compute the SB step, the discrete Schrodinger bridge is approximated using the celebrated Sinkhorn algirthm or an MCMC based method <a href="https://projecteuclid.org/journals/bernoulli/volume-30/issue-3/Asymptotics-of-discrete-Schr%c3%b6dinger-bridges-via-chaos-decomposition/10.3150/23-BEJ1659.full">(Harchaoui et al. (2020))</a>. The comparison between these approaches is considered in <code>SB_approx.ipynb</code>. The detailed mathematical setup and algorithm for computing trhe sample approximation of the SB steps is described in <code>simulations.pdf</code>.</p>
<p>Consider $500$ i.i.d. observations from a mixture of two Gaussians. We approximate the discretized heat flow starting from this distribution by pushing the particles using the SB scheme with a regularization parameter $\varepsilon = 0.1$. Histograms of these particles is plotted below at every 1 time unit. Let $\rho(t)$ be the gradient flow and $\hat \rho(t)$ be the piecewise-constant interpolation of the SB scheme. Both $\rho(t)$ and $\hat \rho(t)$ are also plotted. The histogram provides a finite sample approximation of $\hat \rho(t)$.</p>
<p><img src="./results/sinkhorn/gaussian_mix/forward/eps0.1_time5.png" alt="Local Image"></p>
<h2 id="dependencies">Dependencies</h2>
<p>The following conda environment can be built to run the code. The environment uses Python version 3.12.</p>
<pre class="hljs"><code><div>conda env create -f environment.yml
conda activate gradient_flows
</div></code></pre>
<p>All experiments were conducted on hardware with 125GB of CPU RAM.</p>
<h2 id="reproducing-experimental-results">Reproducing Experimental Results</h2>
<p>If we have $n$ i.i.d. observations from any starting distribution $\rho_0$, we use SB scheme to obtain a discrete approximation of the heat flow starting from $\rho_0$ by running the following code. Replace <code>X</code> by an array-like object of initial particles.</p>
<pre class="hljs"><code><div>from SB_scheme_Entropy import entropy_SB_scheme_sinkhorn
X = np.random.normal(size=(500,))
entropy_SB_scheme_sinkhorn(X, steps=[1, 100], eps=0.01, precision=1e-8)
</div></code></pre>
<p>The functional arguments are</p>
<ul>
<li><code>X</code>: All particles sampled from the initial distribution.</li>
<li><code>steps</code>: List of time steps at which to record the state of the particles.</li>
<li><code>eps</code>: regularization parameter for the Sinkhorn algorithm.</li>
<li><code>precision</code>: precision for the Sinkhorn algorithm convergence.</li>
</ul>
<p>To reproduce the results for the Gaussian family starting measures, one can run</p>
<pre class="hljs"><code><div>python SB_scheme_entropy.py --SB_estimation_method &lt;SB_estimation_method&gt; --source_dist &lt;source_dist&gt; --time &lt;time&gt; --step_size &lt;step_size&gt; --n_particles &lt;n_particles&gt;
</div></code></pre>
<p>where</p>
<ul>
<li><code>&lt;time&gt;</code> is the duration of heat flow to approximate</li>
<li><code>&lt;step_size&gt;</code> is the regularization parameter of the Schrödinger bridge</li>
<li><code>&lt;n_particles&gt;</code> is the number of initial particles
The options for the remaining arguments are</li>
<li><code>&lt;SB_estimation_method&gt;</code>: <code>sinkhorn</code>, <code>mcmc</code></li>
<li><code>&lt;source_dist&gt;</code>: <code>gaussian</code>, <code>gaussian_mix</code>, <code>thin_gaussian</code></li>
</ul>
<h4 id="notebooks">Notebooks</h4>
<ul>
<li>The results for all experiments are visualized in <code>SB_scheme_Entropy.ipynb</code>.</li>
<li>The two methods for approximating the discrete Schrödinger bridge are compared in <code>SB_approx.ipynb</code>.</li>
</ul>
<h2 id="citation">Citation</h2>
<p>If you find this implementation useful, please cite:</p>
<pre class="hljs"><code><div>@article{agarwal2024iterated,
  title={Iterated Schr$\backslash$&quot; odinger bridge approximation to Wasserstein Gradient Flows},
  author={Agarwal, Medha and Harchaoui, Zaid and Mulcahy, Garrett and Pal, Soumik},
  journal={arXiv preprint arXiv:2406.10823},
  year={2024}
}
</div></code></pre>

</body>
</html>
